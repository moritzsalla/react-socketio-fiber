{"ast":null,"code":"import { useState, useRef, useMemo, useEffect } from 'react';\nimport { debounce } from 'debounce';\n\nfunction useMeasure({\n  debounce: debounce$1,\n  scroll,\n  polyfill\n} = {\n  debounce: 0,\n  scroll: false\n}) {\n  const ResizeObserver = polyfill || (typeof window === 'undefined' ? class ResizeObserver {} : window.ResizeObserver);\n\n  if (!ResizeObserver) {\n    throw new Error('This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills');\n  }\n\n  const [bounds, set] = useState({\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0,\n    bottom: 0,\n    right: 0,\n    x: 0,\n    y: 0\n  }); // keep all state in a ref\n\n  const state = useRef({\n    element: null,\n    scrollContainers: null,\n    resizeObserver: null,\n    lastBounds: bounds\n  }); // set actual debounce values early, so effects know if they should react accordingly\n\n  const scrollDebounce = debounce$1 ? typeof debounce$1 === 'number' ? debounce$1 : debounce$1.scroll : null;\n  const resizeDebounce = debounce$1 ? typeof debounce$1 === 'number' ? debounce$1 : debounce$1.resize : null; // memoize handlers, so event-listeners know when they should update\n\n  const [resizeChange, scrollChange] = useMemo(() => {\n    const callback = () => {\n      if (!state.current.element) return;\n      const {\n        left,\n        top,\n        width,\n        height,\n        bottom,\n        right,\n        x,\n        y\n      } = state.current.element.getBoundingClientRect();\n      const size = {\n        left,\n        top,\n        width,\n        height,\n        bottom,\n        right,\n        x,\n        y\n      };\n      Object.freeze(size);\n      if (!areBoundsEqual(state.current.lastBounds, size)) set(state.current.lastBounds = size);\n    };\n\n    return [resizeDebounce ? debounce(callback, resizeDebounce) : callback, scrollDebounce ? debounce(callback, scrollDebounce) : callback];\n  }, [set, scrollDebounce, resizeDebounce]); // cleanup current scroll-listeners / observers\n\n  function removeListeners() {\n    if (state.current.scrollContainers) {\n      state.current.scrollContainers.forEach(element => {\n        element.removeEventListener('scroll', scrollChange, true);\n      });\n      state.current.scrollContainers = null;\n    }\n\n    if (state.current.resizeObserver) {\n      state.current.resizeObserver.disconnect();\n      state.current.resizeObserver = null;\n    }\n  } // add scroll-listeners / observers\n\n\n  function addListeners() {\n    if (!state.current.element) {\n      return;\n    }\n\n    state.current.resizeObserver = new ResizeObserver(scrollChange);\n    state.current.resizeObserver.observe(state.current.element);\n\n    if (scroll && state.current.scrollContainers) {\n      state.current.scrollContainers.forEach(scrollContainer => {\n        scrollContainer.addEventListener('scroll', scrollChange, {\n          capture: true,\n          passive: true\n        });\n      });\n    }\n  } // the ref we expose to the user\n\n\n  const ref = node => {\n    if (!node || node === state.current.element) {\n      return;\n    }\n\n    removeListeners();\n    state.current.element = node;\n    state.current.scrollContainers = findScrollContainers(node);\n    addListeners();\n  }; // add general event listeners\n\n\n  useOnWindowScroll(scrollChange, Boolean(scroll));\n  useOnWindowResize(resizeChange); // respond to changes that are relevant for the listeners\n\n  useEffect(() => {\n    removeListeners();\n    addListeners();\n  }, [scroll, scrollChange, resizeChange]); // remove all listeners when the components unmounts\n\n  useEffect(() => {\n    return removeListeners;\n  }, []);\n  return [ref, bounds];\n} // Adds native resize listener to window\n\n\nfunction useOnWindowResize(onWindowResize) {\n  useEffect(() => {\n    const cb = onWindowResize;\n    window.addEventListener('resize', cb);\n    return () => {\n      window.removeEventListener('resize', cb);\n    };\n  }, [onWindowResize]);\n}\n\nfunction useOnWindowScroll(onScroll, enabled) {\n  useEffect(() => {\n    if (enabled) {\n      const cb = onScroll;\n      window.addEventListener('scroll', cb, {\n        capture: true,\n        passive: true\n      });\n      return () => window.removeEventListener('scroll', cb, true);\n    }\n  }, [onScroll, enabled]);\n} // Returns a list of scroll offsets\n\n\nfunction findScrollContainers(element) {\n  const result = [];\n  if (!element || element === document.body) return result;\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = window.getComputedStyle(element);\n  if ([overflow, overflowX, overflowY].some(prop => prop === 'auto' || prop === 'scroll')) result.push(element);\n  return [...result, ...findScrollContainers(element.parentElement)];\n} // Checks if element boundaries are equal\n\n\nconst keys = ['x', 'y', 'top', 'bottom', 'left', 'right', 'width', 'height'];\n\nconst areBoundsEqual = (a, b) => keys.every(key => a[key] === b[key]);\n\nif (typeof module !== 'undefined' && Object.getOwnPropertyDescriptor && Object.getOwnPropertyDescriptor(module, 'exports').writable) {\n  module.exports = useMeasure;\n}\n\nexport default useMeasure;","map":{"version":3,"sources":["/Users/moritzsalla/Documents/GitHub/react-socketio-fiber/client/node_modules/react-use-measure/dist/web.js"],"names":["useState","useRef","useMemo","useEffect","debounce","useMeasure","debounce$1","scroll","polyfill","ResizeObserver","window","Error","bounds","set","left","top","width","height","bottom","right","x","y","state","element","scrollContainers","resizeObserver","lastBounds","scrollDebounce","resizeDebounce","resize","resizeChange","scrollChange","callback","current","getBoundingClientRect","size","Object","freeze","areBoundsEqual","removeListeners","forEach","removeEventListener","disconnect","addListeners","observe","scrollContainer","addEventListener","capture","passive","ref","node","findScrollContainers","useOnWindowScroll","Boolean","useOnWindowResize","onWindowResize","cb","onScroll","enabled","result","document","body","overflow","overflowX","overflowY","getComputedStyle","some","prop","push","parentElement","keys","a","b","every","key","module","getOwnPropertyDescriptor","writable","exports"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,MAAnB,EAA2BC,OAA3B,EAAoCC,SAApC,QAAqD,OAArD;AACA,SAASC,QAAT,QAAyB,UAAzB;;AAEA,SAASC,UAAT,CAAoB;AAClBD,EAAAA,QAAQ,EAAEE,UADQ;AAElBC,EAAAA,MAFkB;AAGlBC,EAAAA;AAHkB,IAIhB;AACFJ,EAAAA,QAAQ,EAAE,CADR;AAEFG,EAAAA,MAAM,EAAE;AAFN,CAJJ,EAOG;AACD,QAAME,cAAc,GAAGD,QAAQ,KAAK,OAAOE,MAAP,KAAkB,WAAlB,GAAgC,MAAMD,cAAN,CAAqB,EAArD,GAA0DC,MAAM,CAACD,cAAtE,CAA/B;;AAEA,MAAI,CAACA,cAAL,EAAqB;AACnB,UAAM,IAAIE,KAAJ,CAAU,gJAAV,CAAN;AACD;;AAED,QAAM,CAACC,MAAD,EAASC,GAAT,IAAgBb,QAAQ,CAAC;AAC7Bc,IAAAA,IAAI,EAAE,CADuB;AAE7BC,IAAAA,GAAG,EAAE,CAFwB;AAG7BC,IAAAA,KAAK,EAAE,CAHsB;AAI7BC,IAAAA,MAAM,EAAE,CAJqB;AAK7BC,IAAAA,MAAM,EAAE,CALqB;AAM7BC,IAAAA,KAAK,EAAE,CANsB;AAO7BC,IAAAA,CAAC,EAAE,CAP0B;AAQ7BC,IAAAA,CAAC,EAAE;AAR0B,GAAD,CAA9B,CAPC,CAgBG;;AAEJ,QAAMC,KAAK,GAAGrB,MAAM,CAAC;AACnBsB,IAAAA,OAAO,EAAE,IADU;AAEnBC,IAAAA,gBAAgB,EAAE,IAFC;AAGnBC,IAAAA,cAAc,EAAE,IAHG;AAInBC,IAAAA,UAAU,EAAEd;AAJO,GAAD,CAApB,CAlBC,CAuBG;;AAEJ,QAAMe,cAAc,GAAGrB,UAAU,GAAG,OAAOA,UAAP,KAAsB,QAAtB,GAAiCA,UAAjC,GAA8CA,UAAU,CAACC,MAA5D,GAAqE,IAAtG;AACA,QAAMqB,cAAc,GAAGtB,UAAU,GAAG,OAAOA,UAAP,KAAsB,QAAtB,GAAiCA,UAAjC,GAA8CA,UAAU,CAACuB,MAA5D,GAAqE,IAAtG,CA1BC,CA0B2G;;AAE5G,QAAM,CAACC,YAAD,EAAeC,YAAf,IAA+B7B,OAAO,CAAC,MAAM;AACjD,UAAM8B,QAAQ,GAAG,MAAM;AACrB,UAAI,CAACV,KAAK,CAACW,OAAN,CAAcV,OAAnB,EAA4B;AAC5B,YAAM;AACJT,QAAAA,IADI;AAEJC,QAAAA,GAFI;AAGJC,QAAAA,KAHI;AAIJC,QAAAA,MAJI;AAKJC,QAAAA,MALI;AAMJC,QAAAA,KANI;AAOJC,QAAAA,CAPI;AAQJC,QAAAA;AARI,UASFC,KAAK,CAACW,OAAN,CAAcV,OAAd,CAAsBW,qBAAtB,EATJ;AAUA,YAAMC,IAAI,GAAG;AACXrB,QAAAA,IADW;AAEXC,QAAAA,GAFW;AAGXC,QAAAA,KAHW;AAIXC,QAAAA,MAJW;AAKXC,QAAAA,MALW;AAMXC,QAAAA,KANW;AAOXC,QAAAA,CAPW;AAQXC,QAAAA;AARW,OAAb;AAUAe,MAAAA,MAAM,CAACC,MAAP,CAAcF,IAAd;AACA,UAAI,CAACG,cAAc,CAAChB,KAAK,CAACW,OAAN,CAAcP,UAAf,EAA2BS,IAA3B,CAAnB,EAAqDtB,GAAG,CAACS,KAAK,CAACW,OAAN,CAAcP,UAAd,GAA2BS,IAA5B,CAAH;AACtD,KAxBD;;AA0BA,WAAO,CAACP,cAAc,GAAGxB,QAAQ,CAAC4B,QAAD,EAAWJ,cAAX,CAAX,GAAwCI,QAAvD,EAAiEL,cAAc,GAAGvB,QAAQ,CAAC4B,QAAD,EAAWL,cAAX,CAAX,GAAwCK,QAAvH,CAAP;AACD,GA5B2C,EA4BzC,CAACnB,GAAD,EAAMc,cAAN,EAAsBC,cAAtB,CA5ByC,CAA5C,CA5BC,CAwD0C;;AAE3C,WAASW,eAAT,GAA2B;AACzB,QAAIjB,KAAK,CAACW,OAAN,CAAcT,gBAAlB,EAAoC;AAClCF,MAAAA,KAAK,CAACW,OAAN,CAAcT,gBAAd,CAA+BgB,OAA/B,CAAuCjB,OAAO,IAAI;AAChDA,QAAAA,OAAO,CAACkB,mBAAR,CAA4B,QAA5B,EAAsCV,YAAtC,EAAoD,IAApD;AACD,OAFD;AAGAT,MAAAA,KAAK,CAACW,OAAN,CAAcT,gBAAd,GAAiC,IAAjC;AACD;;AAED,QAAIF,KAAK,CAACW,OAAN,CAAcR,cAAlB,EAAkC;AAChCH,MAAAA,KAAK,CAACW,OAAN,CAAcR,cAAd,CAA6BiB,UAA7B;AACApB,MAAAA,KAAK,CAACW,OAAN,CAAcR,cAAd,GAA+B,IAA/B;AACD;AACF,GAtEA,CAsEC;;;AAGF,WAASkB,YAAT,GAAwB;AACtB,QAAI,CAACrB,KAAK,CAACW,OAAN,CAAcV,OAAnB,EAA4B;AAC1B;AACD;;AAEDD,IAAAA,KAAK,CAACW,OAAN,CAAcR,cAAd,GAA+B,IAAIhB,cAAJ,CAAmBsB,YAAnB,CAA/B;AACAT,IAAAA,KAAK,CAACW,OAAN,CAAcR,cAAd,CAA6BmB,OAA7B,CAAqCtB,KAAK,CAACW,OAAN,CAAcV,OAAnD;;AAEA,QAAIhB,MAAM,IAAIe,KAAK,CAACW,OAAN,CAAcT,gBAA5B,EAA8C;AAC5CF,MAAAA,KAAK,CAACW,OAAN,CAAcT,gBAAd,CAA+BgB,OAA/B,CAAuCK,eAAe,IAAI;AACxDA,QAAAA,eAAe,CAACC,gBAAhB,CAAiC,QAAjC,EAA2Cf,YAA3C,EAAyD;AACvDgB,UAAAA,OAAO,EAAE,IAD8C;AAEvDC,UAAAA,OAAO,EAAE;AAF8C,SAAzD;AAID,OALD;AAMD;AACF,GAzFA,CAyFC;;;AAGF,QAAMC,GAAG,GAAGC,IAAI,IAAI;AAClB,QAAI,CAACA,IAAD,IAASA,IAAI,KAAK5B,KAAK,CAACW,OAAN,CAAcV,OAApC,EAA6C;AAC3C;AACD;;AAEDgB,IAAAA,eAAe;AACfjB,IAAAA,KAAK,CAACW,OAAN,CAAcV,OAAd,GAAwB2B,IAAxB;AACA5B,IAAAA,KAAK,CAACW,OAAN,CAAcT,gBAAd,GAAiC2B,oBAAoB,CAACD,IAAD,CAArD;AACAP,IAAAA,YAAY;AACb,GATD,CA5FC,CAqGE;;;AAGHS,EAAAA,iBAAiB,CAACrB,YAAD,EAAesB,OAAO,CAAC9C,MAAD,CAAtB,CAAjB;AACA+C,EAAAA,iBAAiB,CAACxB,YAAD,CAAjB,CAzGC,CAyGgC;;AAEjC3B,EAAAA,SAAS,CAAC,MAAM;AACdoC,IAAAA,eAAe;AACfI,IAAAA,YAAY;AACb,GAHQ,EAGN,CAACpC,MAAD,EAASwB,YAAT,EAAuBD,YAAvB,CAHM,CAAT,CA3GC,CA8GyC;;AAE1C3B,EAAAA,SAAS,CAAC,MAAM;AACd,WAAOoC,eAAP;AACD,GAFQ,EAEN,EAFM,CAAT;AAGA,SAAO,CAACU,GAAD,EAAMrC,MAAN,CAAP;AACD,C,CAAC;;;AAGF,SAAS0C,iBAAT,CAA2BC,cAA3B,EAA2C;AACzCpD,EAAAA,SAAS,CAAC,MAAM;AACd,UAAMqD,EAAE,GAAGD,cAAX;AACA7C,IAAAA,MAAM,CAACoC,gBAAP,CAAwB,QAAxB,EAAkCU,EAAlC;AACA,WAAO,MAAM;AACX9C,MAAAA,MAAM,CAAC+B,mBAAP,CAA2B,QAA3B,EAAqCe,EAArC;AACD,KAFD;AAGD,GANQ,EAMN,CAACD,cAAD,CANM,CAAT;AAOD;;AAED,SAASH,iBAAT,CAA2BK,QAA3B,EAAqCC,OAArC,EAA8C;AAC5CvD,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIuD,OAAJ,EAAa;AACX,YAAMF,EAAE,GAAGC,QAAX;AACA/C,MAAAA,MAAM,CAACoC,gBAAP,CAAwB,QAAxB,EAAkCU,EAAlC,EAAsC;AACpCT,QAAAA,OAAO,EAAE,IAD2B;AAEpCC,QAAAA,OAAO,EAAE;AAF2B,OAAtC;AAIA,aAAO,MAAMtC,MAAM,CAAC+B,mBAAP,CAA2B,QAA3B,EAAqCe,EAArC,EAAyC,IAAzC,CAAb;AACD;AACF,GATQ,EASN,CAACC,QAAD,EAAWC,OAAX,CATM,CAAT;AAUD,C,CAAC;;;AAGF,SAASP,oBAAT,CAA8B5B,OAA9B,EAAuC;AACrC,QAAMoC,MAAM,GAAG,EAAf;AACA,MAAI,CAACpC,OAAD,IAAYA,OAAO,KAAKqC,QAAQ,CAACC,IAArC,EAA2C,OAAOF,MAAP;AAC3C,QAAM;AACJG,IAAAA,QADI;AAEJC,IAAAA,SAFI;AAGJC,IAAAA;AAHI,MAIFtD,MAAM,CAACuD,gBAAP,CAAwB1C,OAAxB,CAJJ;AAKA,MAAI,CAACuC,QAAD,EAAWC,SAAX,EAAsBC,SAAtB,EAAiCE,IAAjC,CAAsCC,IAAI,IAAIA,IAAI,KAAK,MAAT,IAAmBA,IAAI,KAAK,QAA1E,CAAJ,EAAyFR,MAAM,CAACS,IAAP,CAAY7C,OAAZ;AACzF,SAAO,CAAC,GAAGoC,MAAJ,EAAY,GAAGR,oBAAoB,CAAC5B,OAAO,CAAC8C,aAAT,CAAnC,CAAP;AACD,C,CAAC;;;AAGF,MAAMC,IAAI,GAAG,CAAC,GAAD,EAAM,GAAN,EAAW,KAAX,EAAkB,QAAlB,EAA4B,MAA5B,EAAoC,OAApC,EAA6C,OAA7C,EAAsD,QAAtD,CAAb;;AAEA,MAAMhC,cAAc,GAAG,CAACiC,CAAD,EAAIC,CAAJ,KAAUF,IAAI,CAACG,KAAL,CAAWC,GAAG,IAAIH,CAAC,CAACG,GAAD,CAAD,KAAWF,CAAC,CAACE,GAAD,CAA9B,CAAjC;;AAEA,IAAI,OAAOC,MAAP,KAAkB,WAAlB,IAAiCvC,MAAM,CAACwC,wBAAxC,IAAoExC,MAAM,CAACwC,wBAAP,CAAgCD,MAAhC,EAAwC,SAAxC,EAAmDE,QAA3H,EAAqI;AACnIF,EAAAA,MAAM,CAACG,OAAP,GAAiBzE,UAAjB;AACD;;AAED,eAAeA,UAAf","sourcesContent":["import { useState, useRef, useMemo, useEffect } from 'react';\nimport { debounce } from 'debounce';\n\nfunction useMeasure({\n  debounce: debounce$1,\n  scroll,\n  polyfill\n} = {\n  debounce: 0,\n  scroll: false\n}) {\n  const ResizeObserver = polyfill || (typeof window === 'undefined' ? class ResizeObserver {} : window.ResizeObserver);\n\n  if (!ResizeObserver) {\n    throw new Error('This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills');\n  }\n\n  const [bounds, set] = useState({\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0,\n    bottom: 0,\n    right: 0,\n    x: 0,\n    y: 0\n  }); // keep all state in a ref\n\n  const state = useRef({\n    element: null,\n    scrollContainers: null,\n    resizeObserver: null,\n    lastBounds: bounds\n  }); // set actual debounce values early, so effects know if they should react accordingly\n\n  const scrollDebounce = debounce$1 ? typeof debounce$1 === 'number' ? debounce$1 : debounce$1.scroll : null;\n  const resizeDebounce = debounce$1 ? typeof debounce$1 === 'number' ? debounce$1 : debounce$1.resize : null; // memoize handlers, so event-listeners know when they should update\n\n  const [resizeChange, scrollChange] = useMemo(() => {\n    const callback = () => {\n      if (!state.current.element) return;\n      const {\n        left,\n        top,\n        width,\n        height,\n        bottom,\n        right,\n        x,\n        y\n      } = state.current.element.getBoundingClientRect();\n      const size = {\n        left,\n        top,\n        width,\n        height,\n        bottom,\n        right,\n        x,\n        y\n      };\n      Object.freeze(size);\n      if (!areBoundsEqual(state.current.lastBounds, size)) set(state.current.lastBounds = size);\n    };\n\n    return [resizeDebounce ? debounce(callback, resizeDebounce) : callback, scrollDebounce ? debounce(callback, scrollDebounce) : callback];\n  }, [set, scrollDebounce, resizeDebounce]); // cleanup current scroll-listeners / observers\n\n  function removeListeners() {\n    if (state.current.scrollContainers) {\n      state.current.scrollContainers.forEach(element => {\n        element.removeEventListener('scroll', scrollChange, true);\n      });\n      state.current.scrollContainers = null;\n    }\n\n    if (state.current.resizeObserver) {\n      state.current.resizeObserver.disconnect();\n      state.current.resizeObserver = null;\n    }\n  } // add scroll-listeners / observers\n\n\n  function addListeners() {\n    if (!state.current.element) {\n      return;\n    }\n\n    state.current.resizeObserver = new ResizeObserver(scrollChange);\n    state.current.resizeObserver.observe(state.current.element);\n\n    if (scroll && state.current.scrollContainers) {\n      state.current.scrollContainers.forEach(scrollContainer => {\n        scrollContainer.addEventListener('scroll', scrollChange, {\n          capture: true,\n          passive: true\n        });\n      });\n    }\n  } // the ref we expose to the user\n\n\n  const ref = node => {\n    if (!node || node === state.current.element) {\n      return;\n    }\n\n    removeListeners();\n    state.current.element = node;\n    state.current.scrollContainers = findScrollContainers(node);\n    addListeners();\n  }; // add general event listeners\n\n\n  useOnWindowScroll(scrollChange, Boolean(scroll));\n  useOnWindowResize(resizeChange); // respond to changes that are relevant for the listeners\n\n  useEffect(() => {\n    removeListeners();\n    addListeners();\n  }, [scroll, scrollChange, resizeChange]); // remove all listeners when the components unmounts\n\n  useEffect(() => {\n    return removeListeners;\n  }, []);\n  return [ref, bounds];\n} // Adds native resize listener to window\n\n\nfunction useOnWindowResize(onWindowResize) {\n  useEffect(() => {\n    const cb = onWindowResize;\n    window.addEventListener('resize', cb);\n    return () => {\n      window.removeEventListener('resize', cb);\n    };\n  }, [onWindowResize]);\n}\n\nfunction useOnWindowScroll(onScroll, enabled) {\n  useEffect(() => {\n    if (enabled) {\n      const cb = onScroll;\n      window.addEventListener('scroll', cb, {\n        capture: true,\n        passive: true\n      });\n      return () => window.removeEventListener('scroll', cb, true);\n    }\n  }, [onScroll, enabled]);\n} // Returns a list of scroll offsets\n\n\nfunction findScrollContainers(element) {\n  const result = [];\n  if (!element || element === document.body) return result;\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = window.getComputedStyle(element);\n  if ([overflow, overflowX, overflowY].some(prop => prop === 'auto' || prop === 'scroll')) result.push(element);\n  return [...result, ...findScrollContainers(element.parentElement)];\n} // Checks if element boundaries are equal\n\n\nconst keys = ['x', 'y', 'top', 'bottom', 'left', 'right', 'width', 'height'];\n\nconst areBoundsEqual = (a, b) => keys.every(key => a[key] === b[key]);\n\nif (typeof module !== 'undefined' && Object.getOwnPropertyDescriptor && Object.getOwnPropertyDescriptor(module, 'exports').writable) {\n  module.exports = useMeasure;\n}\n\nexport default useMeasure;\n"]},"metadata":{},"sourceType":"module"}